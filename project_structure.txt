
=== /Users/micaelsantana/Documents/app-backend/docker/nginx/default.conf ===

server {
    listen 80;
    server_name api.micasan.com.br;

    # Local onde o Certbot salvará os desafios ACME para renovação do SSL
    location /.well-known/acme-challenge/ {
        root /var/www/letsencrypt;
        allow all;
    }

    # Redireciona todo o tráfego HTTP para HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl;
    server_name api.micasan.com.br;

    # Certificados SSL do Let's Encrypt
    ssl_certificate /etc/letsencrypt/live/api.micasan.com.br/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/api.micasan.com.br/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # Configuração de logs
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    root /var/www/html/public;
    index index.php index.html;

    # Configuração para rodar Laravel no Nginx
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    # Suporte a PHP-FPM com socket UNIX
    location ~ \.php$ {
        include fastcgi_params;
        fastcgi_pass unix:/run/php/php-fpm.sock;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

    # Otimização de cache para arquivos estáticos
    location ~* \.(ico|css|js|gif|jpe?g|png|woff2?|eot|ttf|svg|otf)$ {
        expires 6M;
        access_log off;
        add_header Cache-Control "public";
    }

    # Proteção contra acesso a diretórios sensíveis
    location ~ /\.ht {
        deny all;
    }
}

=== /Users/micaelsantana/Documents/app-backend/docker/nginx/supervisord.conf ===

[supervisord]
nodaemon=true

[program:php-fpm]
command=/usr/local/sbin/php-fpm
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0

[program:nginx]
command=/usr/sbin/nginx -g "daemon off;"
autostart=true
autorestart=true
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
stderr_logfile=/dev/stderr
stderr_logfile_maxbytes=0

=== /Users/micaelsantana/Documents/app-backend/docker-compose.yml ===

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: laravel_app
    restart: unless-stopped
    working_dir: /var/www/html
    volumes:
      - .:/var/www/html
      - /var/www/html/vendor
      - ./storage:/var/www/html/storage
      - ./bootstrap/cache:/var/www/html/bootstrap/cache
      - /run/php:/run/php  # 🛠️ Montar o diretório do socket PHP-FPM
    env_file:
      - .env
    healthcheck:
      test: ["CMD", "php", "-v"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    networks:
      - laravel_network

  nginx:
    image: nginx:alpine
    container_name: nginx_server
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - .:/var/www/html
      - /var/www/html/vendor
      - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf
      - /etc/letsencrypt:/etc/letsencrypt  # ✅ Mount SSL certs into the container
      - /var/lib/letsencrypt:/var/lib/letsencrypt
      - ./certbot-www:/var/www/letsencrypt
      - /run/php:/run/php  # 🛠️ Montar o socket PHP-FPM no Nginx
    depends_on:
      - app
    networks:
      - laravel_network

  certbot:
    image: certbot/certbot
    container_name: certbot
    volumes:
      - /etc/letsencrypt:/etc/letsencrypt
      - /var/lib/letsencrypt:/var/lib/letsencrypt
      - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf
      - ./certbot-www:/var/www/letsencrypt
    depends_on:
      - nginx
    entrypoint: "/bin/sh -c 'trap exit TERM; while :; do certbot renew --webroot -w /var/www/letsencrypt --quiet; sleep 12h & wait $${!}; done'"

networks:
  laravel_network:
    driver: bridge
=== /Users/micaelsantana/Documents/app-backend/Dockerfile ===

# Use PHP 8.2 FPM base image
FROM php:8.2.4-fpm

# Set working directory
WORKDIR /var/www/html

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    curl \
    libpng-dev \
    libonig-dev \
    libxml2-dev \
    zip \
    unzip \
    libpq-dev \
    nginx \
    supervisor \
    certbot \
    libfreetype6-dev \
    libjpeg62-turbo-dev \
    libwebp-dev \
    libxpm-dev \
    zlib1g-dev \
    libzip-dev \
    dnsutils \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Install Node.js and npm (Fix compatibility issues)
RUN curl -fsSL https://deb.nodesource.com/setup_18.x | bash - \
    && apt-get install -y nodejs \
    && npm install -g npm@10

# Configure and install PHP extensions
RUN docker-php-ext-configure gd --with-freetype --with-jpeg --with-webp --with-xpm \
    && docker-php-ext-install gd pdo pdo_pgsql mbstring exif pcntl bcmath zip

# Install Composer
COPY --from=composer:2.5.4 /usr/bin/composer /usr/bin/composer

# Create necessary directories with proper permissions
RUN mkdir -p /var/www/html/storage/framework/sessions \
    /var/www/html/storage/framework/views \
    /var/www/html/storage/framework/cache \
    /var/www/html/bootstrap/cache \
    /var/www/html/deploy \
    /var/www/letsencrypt \
    /certbot-www \
    && chmod -R 775 /var/www/html/storage /var/www/html/bootstrap/cache /var/www/letsencrypt /certbot-www \
    && chown -R www-data:www-data /var/www/html /var/www/letsencrypt /certbot-www

# Set environment variable to allow Composer to run as root/superuser
ENV COMPOSER_ALLOW_SUPERUSER=1

# Copy all application files
COPY . .

# Create an .env file if it doesn't exist
RUN test -f .env || cp .env.example .env

# Install Composer dependencies with proper permissions
RUN composer install --optimize-autoloader --no-dev --no-scripts \
    && php artisan key:generate --force \
    && chown -R www-data:www-data /var/www/html/vendor

# Ensure migrate.sh has execute permissions
RUN if [ -f /var/www/html/deploy/migrate.sh ]; then \
    chmod +x /var/www/html/deploy/migrate.sh; \
    chown www-data:www-data /var/www/html/deploy/migrate.sh; \
fi

# Configure PHP-FPM para usar apenas Unix Socket
RUN sed -i "s|listen = 127.0.0.1:9000|;listen = 127.0.0.1:9000|" /usr/local/etc/php-fpm.d/www.conf \
    && sed -i "s|;listen = /run/php/php-fpm.sock|listen = /run/php/php-fpm.sock|" /usr/local/etc/php-fpm.d/www.conf \
    && echo "listen.owner = www-data" >> /usr/local/etc/php-fpm.d/www.conf \
    && echo "listen.group = www-data" >> /usr/local/etc/php-fpm.d/www.conf \
    && echo "listen.mode = 0660" >> /usr/local/etc/php-fpm.d/www.conf

# Criar diretório do socket do PHP-FPM
RUN mkdir -p /run/php && chown -R www-data:www-data /run/php

# Nginx Configuration
RUN echo 'server { \
    listen 80; \
    server_name _; \
    root /var/www/html/public; \
    index index.php index.html; \
    error_log  /var/log/nginx/error.log; \
    access_log /var/log/nginx/access.log; \
    client_max_body_size 100M; \
    location /.well-known/acme-challenge/ { \
        root /certbot-www; \
        allow all; \
    } \
    location / { \
        try_files $uri $uri/ /index.php?$query_string; \
    } \
    location ~ \.php$ { \
        include fastcgi_params; \
        fastcgi_pass unix:/run/php/php-fpm.sock; \
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; \
        fastcgi_index index.php; \
    } \
}' > /etc/nginx/sites-available/default

# Supervisor configuration para garantir que o PHP-FPM inicia corretamente
RUN echo "[supervisord]\n\
nodaemon=true\n\
user=root\n\
[program:php-fpm]\n\
command=/usr/local/sbin/php-fpm --nodaemonize\n\
autostart=true\n\
autorestart=true\n\
stdout_logfile=/dev/stdout\n\
stdout_logfile_maxbytes=0\n\
stderr_logfile=/dev/stderr\n\
stderr_logfile_maxbytes=0\n\
[program:nginx]\n\
command=/usr/sbin/nginx -g 'daemon off;'\n\
autostart=true\n\
autorestart=true\n\
stdout_logfile=/dev/stdout\n\
stdout_logfile_maxbytes=0\n\
stderr_logfile=/dev/stderr\n\
stderr_logfile_maxbytes=0" > /etc/supervisor/conf.d/supervisord.conf

# Certbot Auto-renewal script
RUN echo '#!/bin/bash\n\
while :; do\n\
  certbot renew --webroot -w /certbot-www --quiet\n\
  sleep 12h\n\
done' > /usr/local/bin/certbot-auto-renew && chmod +x /usr/local/bin/certbot-auto-renew

# Criar o script de inicialização do container
RUN echo '#!/bin/bash\n\
# Garantir que os diretórios existam e tenham as permissões corretas\n\
mkdir -p /var/www/html/storage/framework/sessions\n\
mkdir -p /var/www/html/storage/framework/views\n\
mkdir -p /var/www/html/storage/framework/cache\n\
mkdir -p /var/www/html/bootstrap/cache\n\
mkdir -p /run/php\n\
chown -R www-data:www-data /var/www/html/storage\n\
chown -R www-data:www-data /var/www/html/bootstrap/cache\n\
chown -R www-data:www-data /run/php\n\
\n\
# Executar as migrations do Laravel\n\
if [ -x /var/www/html/deploy/migrate.sh ]; then\n\
    echo "Executando script de migração..."\n\
    bash /var/www/html/deploy/migrate.sh\n\
else\n\
    echo "Rodando Laravel migrations..."\n\
    cd /var/www/html && php artisan migrate --force\n\
fi\n\
\n\
# Iniciar Supervisor (para gerenciar PHP-FPM e Nginx)\n\
exec /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf' > /usr/local/bin/start-container \
    && chmod +x /usr/local/bin/start-container

# Expose ports
EXPOSE 80 443

# Start the container
CMD ["/usr/local/bin/start-container"]
=== /Users/micaelsantana/Documents/app-backend/deploy.sh ===

#!/bin/bash

set -e  # Exit script on any error

echo "🚀 Starting Deployment Process"

# Ensure project directory exists, clone if missing
if [ ! -d "/var/www/app-backend" ]; then
    echo "🔄 Cloning repository..."
    git clone git@github.com:douglashub/app-backend.git /var/www/app-backend
fi

# Navigate to the project directory
cd /var/www/app-backend || exit

echo "🔄 Pulling Latest Code with Rebase Strategy..."
git fetch origin main
git reset --hard origin/main
git pull --rebase origin main

echo "🔍 Checking Docker Installation..."
if ! command -v docker &> /dev/null; then
    echo "🚨 Docker is not installed. Installing now..."
    apt update && apt install -y docker.io
    systemctl start docker
    systemctl enable docker
fi

echo "🔍 Checking Docker Compose Installation..."
if ! command -v docker-compose &> /dev/null; then
    echo "🚨 Docker Compose not found. Installing now..."
    curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
    chmod +x /usr/local/bin/docker-compose
fi

echo "📝 Setting Up Environment Variables..."
if [ ! -f ".env" ]; then
    echo "⚠️ .env file missing! Creating from example..."
    cp .env.example .env
fi

# Ensure database credentials are set in .env
sed -i "s|DB_HOST=.*|DB_HOST=db-postgres-api-micasan-do-user-20111967-0.f.db.ondigitalocean.com|" .env
sed -i "s|DB_PORT=.*|DB_PORT=25060|" .env
sed -i "s|DB_DATABASE=.*|DB_DATABASE=defaultdb|" .env
sed -i "s|DB_USERNAME=.*|DB_USERNAME=doadmin|" .env
sed -i "s|DB_PASSWORD=.*|DB_PASSWORD=AVNS_UnYjI2qmb8fsv0PgrYN|" .env

# Corrigir a configuração do PHP-FPM no Dockerfile antes de construir
echo "🔧 Corrigindo a configuração do PHP-FPM no Dockerfile..."
# Verificar se o Dockerfile existe
if [ -f "Dockerfile" ]; then
    # Fazer backup do Dockerfile original
    cp Dockerfile Dockerfile.bak
    
    # Modificar a configuração do PHP-FPM no Dockerfile
    sed -i '/# Configure PHP-FPM/,/# Nginx Configuration/c\
# Configure PHP-FPM para usar apenas Unix Socket\
RUN sed -i "s|listen = 127.0.0.1:9000|;listen = 127.0.0.1:9000|" /usr/local/etc/php-fpm.d/www.conf \\\
    && sed -i "s|;listen = /run/php/php-fpm.sock|listen = /run/php/php-fpm.sock|" /usr/local/etc/php-fpm.d/www.conf \\\
    && echo "listen.owner = www-data" >> /usr/local/etc/php-fpm.d/www.conf \\\
    && echo "listen.group = www-data" >> /usr/local/etc/php-fpm.d/www.conf \\\
    && echo "listen.mode = 0660" >> /usr/local/etc/php-fpm.d/www.conf\
\
# Criar diretório do socket do PHP-FPM\
RUN mkdir -p /run/php && chown -R www-data:www-data /run/php\
\
# Instalar killall para poder gerenciar processos\
RUN apt-get update && apt-get install -y psmisc procps\
\
# Nginx Configuration' Dockerfile
    
    echo "✅ Dockerfile atualizado com sucesso para corrigir o PHP-FPM!"
else
    echo "❌ Dockerfile não encontrado! Verifique o caminho."
fi

# Corrigir a configuração do zz-docker.conf que está causando conflito
echo "🔧 Modificando o arquivo zz-docker.conf para evitar conflitos de socket..."
cat > docker-php-entrypoint-override.sh << 'EOF'
#!/bin/sh
set -e

# Primeiro, modificar a configuração no zz-docker.conf
if [ -f /usr/local/etc/php-fpm.d/zz-docker.conf ]; then
  echo "⚡ Reconfigurando o arquivo zz-docker.conf..."
  # Comentar a linha 'listen = 9000' que está causando conflito
  sed -i 's|listen = 9000|;listen = 9000|g' /usr/local/etc/php-fpm.d/zz-docker.conf
fi

# Garantir que o diretório do socket existe
mkdir -p /run/php
chown -R www-data:www-data /run/php

# Executar o comando original
exec "$@"
EOF

chmod +x docker-php-entrypoint-override.sh

# Criar um novo Dockerfile.override para incluir o script acima
cat > Dockerfile.override << 'EOF'
# Use o Dockerfile existente como base
FROM app-backend-app:latest

# Copiar o script de override para o entrypoint
COPY docker-php-entrypoint-override.sh /usr/local/bin/
ENTRYPOINT ["/usr/local/bin/docker-php-entrypoint-override.sh"]
CMD ["/usr/local/bin/start-container"]
EOF

echo "🐳 Stopping and Removing Old Containers..."
docker-compose down --volumes --remove-orphans

echo "🐳 Building and Restarting Docker Containers..."
docker-compose up -d --build

# ✅ Ensure Database is Reachable Before Running Migrations
MAX_ATTEMPTS=10
ATTEMPT=0
DB_HOST="db-postgres-api-micasan-do-user-20111967-0.f.db.ondigitalocean.com"
DB_PORT="25060"

echo "🔄 Checking PostgreSQL Connection..."
while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
    echo "Checking PostgreSQL connection (Attempt $((ATTEMPT+1))/$MAX_ATTEMPTS)"
    if nc -zv $DB_HOST $DB_PORT; then
        echo "✅ PostgreSQL is reachable."
        break
    fi
    sleep 5
    ATTEMPT=$((ATTEMPT+1))
done

if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
    echo "❌ Failed to connect to PostgreSQL after $MAX_ATTEMPTS attempts."
    exit 1
fi

# Dar tempo para os containers inicializarem completamente
echo "⏳ Aguardando 15 segundos para os containers inicializarem completamente..."
sleep 15

# Corrigir o PHP-FPM diretamente no container
echo "🔧 Corrigindo o PHP-FPM diretamente no container..."
docker-compose exec -T app bash -c "
    echo '📋 Verificando configuração atual do PHP-FPM...'
    grep -r 'listen =' /usr/local/etc/php-fpm.d/
    
    echo '🔄 Aplicando correções ao PHP-FPM...'
    # Comentar todas as linhas de listen existentes
    sed -i 's|listen = |;listen = |g' /usr/local/etc/php-fpm.d/zz-docker.conf
    sed -i 's|listen = |;listen = |g' /usr/local/etc/php-fpm.d/www.conf
    
    # Adicionar a configuração correta
    echo 'listen = /run/php/php-fpm.sock' >> /usr/local/etc/php-fpm.d/www.conf
    echo 'listen.owner = www-data' >> /usr/local/etc/php-fpm.d/www.conf
    echo 'listen.group = www-data' >> /usr/local/etc/php-fpm.d/www.conf
    echo 'listen.mode = 0660' >> /usr/local/etc/php-fpm.d/www.conf
    
    # Garantir que o diretório existe
    mkdir -p /run/php
    chown -R www-data:www-data /run/php
    
    # Reiniciar o PHP-FPM
    if command -v killall > /dev/null 2>&1; then
        killall php-fpm || true
    elif ps aux | grep -v grep | grep php-fpm > /dev/null; then
        pkill php-fpm || true
    fi
    
    # Iniciar PHP-FPM em modo standalone para debug
    echo '🔄 Reiniciando PHP-FPM...'
    /usr/local/sbin/php-fpm --nodaemonize &
    
    # Esperar um pouco para o socket ser criado
    sleep 5
    
    # Verificar se o socket foi criado
    if [ -S /run/php/php-fpm.sock ]; then
        echo '✅ Socket PHP-FPM criado com sucesso!'
        ls -la /run/php/
    else
        echo '❌ Falha ao criar o socket PHP-FPM!'
    fi
" || true  # Permitir que o script continue mesmo se este comando falhar

# ✅ Restart Laravel Config & Cache
echo "🔄 Clearing Laravel Cache..."
docker-compose exec -T app php artisan config:clear
docker-compose exec -T app php artisan cache:clear
docker-compose exec -T app php artisan config:cache

# ✅ Install Dependencies
echo "📦 Installing Laravel Dependencies..."
docker-compose exec -T app composer install --no-dev --optimize-autoloader

# ✅ Ensure `npm` is installed before running frontend dependencies
echo "⚡ Checking if Node.js and npm are installed..."
docker-compose exec -T app bash -c "command -v node && command -v npm"
if [ $? -ne 0 ]; then
    echo "❌ Node.js and npm not found. Installing..."
    docker-compose exec -T app bash -c "curl -fsSL https://deb.nodesource.com/setup_18.x | bash - && apt-get install -y nodejs npm"
fi

# ✅ Install Frontend Dependencies
echo "⚡ Installing Frontend Dependencies..."
docker-compose exec -T app bash -c "npm install && npm run build"

# ✅ Run Database Migrations
echo "📊 Running Laravel Migrations..."
docker-compose exec -T app php artisan migrate --force

# ✅ Restart Nginx (inside container, not host service)
echo "🔄 Restarting Nginx Container..."
docker-compose restart nginx

# Aguardar reinicialização completa
sleep 5

# Verificação final
echo "🔍 Executando verificação final do serviço..."
# Primeiro verificar se podemos acessar o socket do PHP-FPM
echo "Verificando socket PHP-FPM..."
docker-compose exec -T app bash -c "ls -la /run/php/"

# Verificar permissões do socket
echo "Verificando permissões do socket..."
docker-compose exec -T app bash -c "stat -c '%a %U:%G' /run/php/php-fpm.sock 2>/dev/null || echo 'Socket não encontrado'"

# Verificar logs do PHP-FPM
echo "Verificando logs do PHP-FPM..."
docker-compose exec -T app bash -c "tail -n 10 /var/log/php-fpm.log 2>/dev/null || echo 'Log do PHP-FPM não encontrado'"

# Verificar se o site está acessível externamente
echo "Verificando acesso ao site..."
if curl -sk --head https://api.micasan.com.br | grep -E "HTTP/[0-9]\.[0-9] [2-3][0-9][0-9]"; then
    echo "✅ Site está acessível externamente! A comunicação Nginx-PHP-FPM está funcionando corretamente!"
else
    echo "❌ Problemas ao acessar o site externamente! Verificando logs:"
    docker-compose logs --tail=50 nginx
    docker-compose logs --tail=20 app
fi

echo "✅ Deployment Completed Successfully!"